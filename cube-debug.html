<!doctype html>
<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Cube Debug</title>
    <style>
      :root {
        --bg: #0e1014;
        --panel: #151922;
        --text: #f4f6fb;
        --muted: #b9c0d1;
        --accent: #f7b32b;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Space Grotesk", "Segoe UI", sans-serif;
        background: var(--bg);
        color: var(--text);
        min-height: 100vh;
        padding: 140px 24px 24px;
      }

      h1,
      h2 {
        margin: 0 0 12px 0;
      }

      .fixed-header {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        background: var(--panel);
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        z-index: 10;
      }

      .header-inner {
        max-width: 1200px;
        margin: 0 auto;
        padding: 16px 24px;
        display: flex;
        align-items: center;
        gap: 16px;
        flex-wrap: wrap;
      }

      .header-title {
        margin: 0;
        font-size: 22px;
        letter-spacing: -0.01em;
      }

      .layout {
        display: grid;
        gap: 16px;
      }

      .panels {
        display: grid;
        gap: 16px;
        grid-template-columns: repeat(3, minmax(240px, 1fr));
      }

      .panel {
        background: var(--panel);
        border-radius: 16px;
        padding: 16px;
        display: grid;
        gap: 12px;
      }

      .controls {
        display: grid;
        grid-template-columns: minmax(220px, 1fr) auto auto auto;
        gap: 8px;
        align-items: center;
        flex: 1;
      }

      input[type="text"],
      select {
        width: 100%;
        padding: 8px 10px;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        background: #0f1320;
        color: var(--text);
      }

      button {
        border: none;
        background: #222a3a;
        color: var(--text);
        padding: 8px 12px;
        border-radius: 10px;
        cursor: pointer;
        font-weight: 600;
      }

      button:hover {
        background: #2b3550;
      }

      pre {
        background: #0f1320;
        padding: 12px;
        border-radius: 12px;
        color: var(--text);
        margin: 0;
        white-space: pre;
        font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
        font-size: 13px;
      }

      .legend {
        color: var(--muted);
        font-size: 13px;
      }

      .history {
        display: grid;
        gap: 10px;
        max-height: 50vh;
        overflow: auto;
      }

      details {
        background: #0f1320;
        padding: 8px;
        border-radius: 10px;
      }

      summary {
        cursor: pointer;
        color: var(--accent);
        font-weight: 600;
      }

      .history-block {
        display: grid;
        gap: 8px;
      }

      .c {
        font-weight: 700;
      }

      .c-Y {
        color: #f6c445;
      }

      .c-W {
        color: #f4f6fb;
      }

      .c-R {
        color: #ff3b3b;
      }

      .c-G {
        color: #2ecc71;
      }

      .c-O {
        color: #ff7a30;
      }

      .c-B {
        color: #2d6cdf;
      }

      .c-empty {
        color: #495063;
      }

      @media (max-width: 900px) {
        .panels {
          grid-template-columns: 1fr;
        }

        .controls {
          grid-template-columns: 1fr 1fr;
        }

        body {
          padding-top: 200px;
        }
      }
    </style>
  </head>
  <body>
    <header class="fixed-header">
      <div class="header-inner">
        <h1 class="header-title">Cube debug</h1>
        <div class="controls">
          <input id="sequence" type="text" value="R U R' U'" />
          <button id="apply">Apply</button>
          <button id="reset">Reset</button>
          <button id="snapshot">Snapshot</button>
        </div>
      </div>
    </header>

    <div class="layout">

      <div class="panels">
        <section class="panel">
          <h2>List view</h2>
          <pre id="state-list"></pre>
        </section>

        <section class="panel">
          <h2>Net view</h2>
          <pre id="state-net"></pre>
        </section>

        <section class="panel">
          <h2>Layers</h2>
          <pre id="state-layers"></pre>
        </section>
      </div>

      <section class="panel">
        <h2>History</h2>
        <div id="history" class="history"></div>
      </section>
    </div>

    <script>
      const FACE_CODE = {
        U: "Y",
        D: "W",
        F: "R",
        R: "G",
        L: "B",
        B: "O",
      };

      const FACE_NAMES = ["U", "R", "F", "D", "L", "B"];
      let size = 3;
      let coords = [];
      let maxCoord = 1;
      let minCoord = -1;
      let stickers = [];
      let step = 0;

      const listEl = document.getElementById("state-list");
      const netEl = document.getElementById("state-net");
      const layersEl = document.getElementById("state-layers");
      const historyEl = document.getElementById("history");

      function buildCoords() {
        coords = Array.from({ length: size }, (_, i) => i - (size - 1) / 2);
        maxCoord = coords[coords.length - 1];
        minCoord = coords[0];
      }

      function createSolvedStickers() {
        const result = [];
        const add = (x, y, z, nx, ny, nz, face) => {
          result.push({
            pos: { x, y, z },
            normal: { x: nx, y: ny, z: nz },
            color: FACE_CODE[face],
          });
        };

        coords.forEach((x) => {
          coords.forEach((z) => {
            add(x, maxCoord, z, 0, 1, 0, "U");
            add(x, minCoord, z, 0, -1, 0, "D");
          });
        });

        coords.forEach((x) => {
          coords.forEach((y) => {
            add(x, y, maxCoord, 0, 0, 1, "F");
            add(x, y, minCoord, 0, 0, -1, "B");
          });
        });

        coords.forEach((z) => {
          coords.forEach((y) => {
            add(maxCoord, y, z, 1, 0, 0, "R");
            add(minCoord, y, z, -1, 0, 0, "L");
          });
        });

        return result;
      }

      function rotate90({ x, y, z }, axis, direction) {
        if (axis === "x") {
          return direction > 0
            ? { x, y: -z, z: y }
            : { x, y: z, z: -y };
        }
        if (axis === "y") {
          return direction > 0
            ? { x: z, y, z: -x }
            : { x: -z, y, z: x };
        }
        return direction > 0
          ? { x: -y, y: x, z }
          : { x: y, y: -x, z };
      }

      function isLayer(pos, axis, layerValue) {
        return Math.abs(pos[axis] - layerValue) < 1e-6;
      }

      function rotateLayer(axis, layerValue, turns) {
        const direction = turns > 0 ? 1 : -1;
        const steps = Math.abs(turns);

        for (let stepIdx = 0; stepIdx < steps; stepIdx += 1) {
          stickers = stickers.map((sticker) => {
            if (!isLayer(sticker.pos, axis, layerValue)) {
              return sticker;
            }

            const newPos = rotate90(sticker.pos, axis, direction);
            const newNormal = rotate90(sticker.normal, axis, direction);
            return {
              ...sticker,
              pos: newPos,
              normal: newNormal,
            };
          });
        }
      }

      function applyMove(move) {
        const base = move[0];
        const modifier = move[1] || "";
        let turns = 1;
        if (modifier === "2") turns = 2;
        if (modifier === "'") turns = -1;

        switch (base) {
          case "U":
            rotateLayer("y", maxCoord, -turns);
            break;
          case "D":
            rotateLayer("y", minCoord, turns);
            break;
          case "R":
            rotateLayer("x", maxCoord, -turns);
            break;
          case "L":
            rotateLayer("x", minCoord, turns);
            break;
          case "F":
            rotateLayer("z", maxCoord, -turns);
            break;
          case "B":
            rotateLayer("z", minCoord, turns);
            break;
          default:
            break;
        }
      }

      function parseSequence(sequence) {
        return sequence
          .trim()
          .split(/\s+/)
          .filter(Boolean)
          .flatMap((token) => {
            const match = token.match(/^([URFDLB])([2']?)$/);
            return match ? [match[1] + match[2]] : [];
          });
      }

      function getFaceIndex(face, pos) {
        const { x, y, z } = pos;
        const idx = (value) => coords.indexOf(value);

        if (face === "U") {
          return idx(z) * size + idx(x);
        }
        if (face === "D") {
          return (size - 1 - idx(z)) * size + idx(x);
        }
        if (face === "F") {
          return (size - 1 - idx(y)) * size + idx(x);
        }
        if (face === "B") {
          return (size - 1 - idx(y)) * size + (size - 1 - idx(x));
        }
        if (face === "R") {
          return (size - 1 - idx(y)) * size + (size - 1 - idx(z));
        }
        return (size - 1 - idx(y)) * size + idx(z);
      }

      function faceColors() {
        const colors = {
          U: Array(size * size).fill("."),
          D: Array(size * size).fill("."),
          F: Array(size * size).fill("."),
          B: Array(size * size).fill("."),
          L: Array(size * size).fill("."),
          R: Array(size * size).fill("."),
        };

        stickers.forEach((sticker) => {
          const n = sticker.normal;
          let face = "F";
          if (n.y === 1) face = "U";
          else if (n.y === -1) face = "D";
          else if (n.z === 1) face = "F";
          else if (n.z === -1) face = "B";
          else if (n.x === 1) face = "R";
          else if (n.x === -1) face = "L";

          const index = getFaceIndex(face, sticker.pos);
          colors[face][index] = sticker.color;
        });

        return colors;
      }

      function faceLines(face, colors) {
        const lines = [];
        for (let row = 0; row < size; row += 1) {
          const start = row * size;
          lines.push(colors[face].slice(start, start + size));
        }
        return lines;
      }

      function blankLines(faceWidth) {
        return Array(size).fill(" ".repeat(faceWidth));
      }

      function mergeRow(rows, spacer) {
        return rows[0].map((_, index) => rows.map((row) => row[index]).join(spacer));
      }

      function formatCell(code) {
        if (code === ".") {
          return `<span class="c c-empty">.</span>`;
        }
        return `<span class="c c-${code}">${code}</span>`;
      }

      function formatRow(row) {
        return row.map(formatCell).join(" ");
      }

      function formatList(colors) {
        const faceWidth = size * 2 - 1;
        const padLabel = (label) => {
          const left = Math.floor((faceWidth - 1) / 2);
          const right = faceWidth - 1 - left;
          return `${" ".repeat(left)}${label}${" ".repeat(right)}`;
        };

        const faces = ["U", "R", "F", "D", "L", "B"].map((face) => ({
          face,
          rows: faceLines(face, colors).map(formatRow),
        }));

        const blocks = faces.map((block) => {
          return [padLabel(block.face), ...block.rows];
        });

        const spacer = "   ";
        const merged = mergeRow(blocks, spacer);
        return merged.join("\n");
      }

      function formatNetClassic(colors) {
        const faceWidth = size * 2 - 1;
        const spacer = "   ";
        const U = faceLines("U", colors).map(formatRow);
        const D = faceLines("D", colors).map(formatRow);
        const L = faceLines("L", colors).map(formatRow);
        const F = faceLines("F", colors).map(formatRow);
        const R = faceLines("R", colors).map(formatRow);
        const B = faceLines("B", colors).map(formatRow);
        const blank = blankLines(faceWidth);

        return [
          ...mergeRow([blank, U, B], spacer),
          ...mergeRow([L, F, R], spacer),
          ...mergeRow([blank, D, blank], spacer),
        ].join("\n");
      }

      function layerRowIndex(y) {
        return size - 1 - coords.indexOf(y);
      }

      function formatLayerRow(y, colors) {
        const rowIndex = layerRowIndex(y);
        const rowNumber = coords.indexOf(y) + 1;
        const grids = {
          F: faceLines("F", colors),
          R: faceLines("R", colors),
          B: faceLines("B", colors),
          L: faceLines("L", colors),
          U: faceLines("U", colors),
          D: faceLines("D", colors),
        };

        const ring = ["F", "R", "B", "L"].map((face) => {
          return `${face}: ${formatRow(grids[face][rowIndex])}`;
        });

        return [`(row ${rowNumber}):`, ring.join(" | ")].join("\n");
      }

      function formatLayers(colors) {
        const top = faceLines("U", colors).map(formatRow);
        const bottom = faceLines("D", colors).map(formatRow);
        const rows = [...coords].reverse().map((y) => formatLayerRow(y, colors));
        return [
          "U:",
          ...top,
          "",
          rows.join("\n\n"),
          "",
          "D:",
          ...bottom,
        ].join("\n");
      }

      function renderViews() {
        const colors = faceColors();
        listEl.innerHTML = formatList(colors);
        netEl.innerHTML = formatNetClassic(colors);
        layersEl.innerHTML = formatLayers(colors);
      }

      function logState(label) {
        const entry = document.createElement("details");
        entry.open = false;
        const summary = document.createElement("summary");
        summary.textContent = label;
        const wrapper = document.createElement("div");
        wrapper.className = "history-block";

        const netTitle = document.createElement("div");
        netTitle.textContent = "Net view";
        const netPre = document.createElement("pre");
        netPre.innerHTML = formatNetClassic(faceColors());

        const layerTitle = document.createElement("div");
        layerTitle.textContent = "Layers";
        const layerPre = document.createElement("pre");
        layerPre.innerHTML = formatLayers(faceColors());

        const listTitle = document.createElement("div");
        listTitle.textContent = "List view";
        const listPre = document.createElement("pre");
        listPre.innerHTML = formatList(faceColors());

        wrapper.appendChild(netTitle);
        wrapper.appendChild(netPre);
        wrapper.appendChild(layerTitle);
        wrapper.appendChild(layerPre);
        wrapper.appendChild(listTitle);
        wrapper.appendChild(listPre);
        entry.appendChild(summary);
        entry.appendChild(wrapper);
        historyEl.prepend(entry);
      }

      function resetCube() {
        buildCoords();
        stickers = createSolvedStickers();
        step = 0;
        historyEl.innerHTML = "";
        renderViews();
      }

      document.getElementById("apply").addEventListener("click", () => {
        const input = document.getElementById("sequence");
        const moves = parseSequence(input.value);
        if (!moves.length) return;
        moves.forEach((move) => {
          applyMove(move);
          step += 1;
          logState(`Step ${step}: ${move}`);
        });
        renderViews();
      });

      document.getElementById("reset").addEventListener("click", () => {
        resetCube();
      });

      document.getElementById("snapshot").addEventListener("click", () => {
        step += 1;
        logState(`Step ${step}: snapshot`);
      });

      resetCube();
    </script>
  </body>
</html>
