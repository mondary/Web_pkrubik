<!doctype html>
<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Rubik's Cube 3x3 Simulator</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />
    <style>
      :root {
        --bg: #0e1014;
        --panel: #151922;
        --panel-2: #1b2130;
        --text: #f4f6fb;
        --muted: #b9c0d1;
        --accent: #f7b32b;
        --face-u: #f6c445;
        --face-d: #f4f6fb;
        --face-f: #ff3b3b;
        --face-r: #2ecc71;
        --face-l: #2d6cdf;
        --face-b: #ff7a30;
        --sticker-border: #111;
        --size: 240px;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Space Grotesk", "Segoe UI", sans-serif;
        background: radial-gradient(circle at 20% 20%, #1a2030 0, transparent 45%),
          radial-gradient(circle at 80% 10%, #252c40 0, transparent 40%),
          var(--bg);
        color: var(--text);
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 32px 16px;
      }

      .app {
        width: min(1100px, 100%);
        display: grid;
        gap: 24px;
      }

      header {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      h1 {
        font-size: clamp(26px, 4vw, 42px);
        margin: 0;
        letter-spacing: -0.02em;
      }

      p {
        margin: 0;
        color: var(--muted);
        line-height: 1.5;
      }

      .layout {
        display: grid;
        gap: 24px;
        grid-template-columns: minmax(280px, 1.1fr) minmax(260px, 0.9fr);
        align-items: start;
      }

      .stage {
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.06), transparent);
        border-radius: 24px;
        padding: 24px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        display: grid;
        gap: 18px;
      }

      .viewport {
        perspective: 900px;
        width: 100%;
        aspect-ratio: 1 / 1;
        display: grid;
        place-items: center;
      }

      .cube {
        width: var(--size);
        height: var(--size);
        position: relative;
        transform-style: preserve-3d;
        transition: transform 0.2s ease-out;
        --n: 3;
        --gap: 6px;
        --pad: 10px;
      }

      .face {
        position: absolute;
        width: var(--size);
        height: var(--size);
        display: grid;
        grid-template-columns: repeat(var(--n), 1fr);
        grid-template-rows: repeat(var(--n), 1fr);
        gap: var(--gap);
        padding: var(--pad);
        background: rgba(0, 0, 0, 0.3);
        border-radius: 18px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        backface-visibility: hidden;
        overflow: visible;
      }

      .sticker {
        border-radius: 10px;
        border: 2px solid var(--sticker-border);
        box-shadow: inset 0 0 12px rgba(0, 0, 0, 0.35);
        transition: background-color 0.15s ease-out;
      }

      .move-indicator {
        position: absolute;
        top: 6px;
        right: 6px;
        width: 22px;
        height: 22px;
        border-radius: 6px;
        background: rgba(15, 19, 32, 0.85);
        border: 1px solid rgba(255, 255, 255, 0.12);
        display: grid;
        place-items: center;
        font-size: 12px;
        font-weight: 700;
        color: #f4f6fb;
        pointer-events: none;
      }

      .panel {
        background: var(--panel);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 24px;
        padding: 22px;
        display: grid;
        gap: 18px;
      }

      .moves {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 10px;
      }

      button {
        border: none;
        padding: 10px 12px;
        border-radius: 12px;
        background: var(--panel-2);
        color: var(--text);
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.12s ease, background 0.12s ease;
        display: inline-flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        text-align: left;
      }

      button:hover {
        background: #27314a;
        transform: translateY(-1px);
      }

      .move-icon {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        opacity: 0.9;
      }

      .move-icon svg {
        width: 22px;
        height: 22px;
      }

      .action-row {
        display: grid;
        gap: 10px;
      }

      .algo-label {
        display: inline-flex;
        gap: 6px;
        align-items: center;
        flex-wrap: wrap;
      }

      .move-step {
        padding: 0 2px;
        border-radius: 6px;
        color: var(--muted);
      }

      .notation-lowercase .move-step {
        font-family: "Georgia", "Times New Roman", serif;
      }

      .move-step.active {
        background: rgba(247, 179, 43, 0.18);
      }

      .move-step.active[data-face="U"] {
        color: var(--face-u);
      }

      .move-step.active[data-face="D"] {
        color: var(--face-d);
      }

      .move-step.active[data-face="F"] {
        color: var(--face-f);
      }

      .move-step.active[data-face="R"] {
        color: var(--face-r);
      }

      .move-step.active[data-face="L"] {
        color: var(--face-l);
      }

      .move-step.active[data-face="B"] {
        color: var(--face-b);
      }

      .algo-row {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 8px;
        align-items: stretch;
      }

      .algo-notation {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }

      .algo-notation button {
        justify-content: center;
        padding: 6px 10px;
        font-size: 13px;
      }

      .algo-step {
        white-space: nowrap;
        justify-content: center;
      }

      input[type="text"],
      select {
        width: 100%;
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        background: #0f1320;
        color: var(--text);
        font-size: 14px;
      }

      .segmented {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 6px;
        background: #0f1320;
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 12px;
        padding: 4px;
      }

      .segmented button {
        padding: 8px 10px;
        border-radius: 8px;
        background: transparent;
        font-size: 13px;
      }

      .segmented button.active {
        background: #27314a;
      }

      .controls-row {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 10px;
        align-items: center;
      }

      .icon-actions {
        display: grid;
        grid-auto-flow: column;
        gap: 8px;
      }

      .icon-actions button {
        width: 36px;
        height: 36px;
        border-radius: 10px;
        justify-content: center;
        font-size: 16px;
        color: #f4f6fb;
      }

      .notation-row {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 8px;
        align-items: center;
      }

      .stat {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        padding: 10px 12px;
        border-radius: 12px;
        background: #0f1320;
        border: 1px solid rgba(255, 255, 255, 0.08);
      }

      .small {
        font-size: 13px;
        color: var(--muted);
      }

      .pill {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 10px;
        border-radius: 999px;
        background: rgba(247, 179, 43, 0.15);
        color: var(--accent);
        font-weight: 600;
        font-size: 12px;
      }

      .coords-overlay {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: #f4f6fb;
        padding: 4px 8px;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 600;
        pointer-events: none;
      }

      .moves-overlay {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: #f4f6fb;
        padding: 4px 8px;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 600;
        pointer-events: none;
      }

      @media (max-width: 900px) {
        .layout {
          grid-template-columns: 1fr;
        }

        .cube {
          width: min(72vw, 260px);
          height: min(72vw, 260px);
        }
      }
    </style>
  </head>
  <body>
    <div class="app">
       <header>
         <h1>Simulateur Rubik's Cube</h1>
         <p>Faites tourner le cube, appliquez des mouvements et saisissez vos algorithmes.</p>
       </header>

      <section class="layout">
         <div class="stage">
             <div class="viewport" id="viewport">
              <div class="cube" id="cube"></div>
              <div class="coords-overlay" id="coords-overlay">rotX: 0, rotY: 0</div>
              <div class="moves-overlay" id="moves-overlay">Mouvements: 0</div>
            </div>
           <p class="small">
             Glissez pour orienter le cube. Les mouvements utilisent la notation internationale (U, D, L, R, F, B).
           </p>
         </div>

        <aside class="panel">
           <div class="action-row">
             <strong>Cube</strong>
           <select id="cube-type">
             <option value="2">2x2</option>
             <option value="3" selected>3x3</option>
             <option value="3-twisted">3x3 twisted</option>
             <option value="4">4x4</option>
           </select>
           <div class="controls-row">
             <div class="segmented" id="speed-segment">
               <button type="button" data-speed="600" aria-label="Lent">üê¢</button>
               <button type="button" data-speed="350" class="active" aria-label="Normal">üêá</button>
               <button type="button" data-speed="180" aria-label="Rapide">‚ö°</button>
             </div>
             <div class="icon-actions">
               <button type="button" id="reset" aria-label="Reinitialiser"><i class="fa-solid fa-rotate-left"></i></button>
               <button type="button" id="scramble" aria-label="Melanger"><i class="fa-solid fa-shuffle"></i></button>
             </div>
           </div>
           <input type="hidden" id="speed" value="350" />
          </div>

          <div class="action-row">
            <strong>Notation</strong>
            <div class="notation-row">
              <input id="sequence-input" type="text" placeholder="R U R' U'" />
              <button id="apply-sequence" aria-label="Appliquer la sequence"><i class="fa-solid fa-play"></i></button>
            </div>
          </div>

          <div class="action-row">
            <strong>Mouvements rapides</strong>
            <div class="moves" id="move-buttons"></div>
            <div class="segmented algo-notation" id="algo-notation">
              <button type="button" data-notation="standard" class="active" aria-label="Notation standard">R / R'</button>
              <button type="button" data-notation="lowercase" aria-label="Notation minuscule">R / r</button>
              <button type="button" data-notation="arrows" aria-label="Notation fleches">R‚Üë / R‚Üì</button>
            </div>
            <div class="algo-row">
              <button id="sexy-move" class="algo-main" type="button" data-algo="sexy" data-label="üî• Sexy move" data-seq="R U R' U'">üî• Sexy move</button>
              <button class="algo-step" type="button" data-algo="sexy" aria-label="Pas a pas"><i class="fa-solid fa-forward-step"></i></button>
            </div>
            <div class="algo-row">
              <button id="left-hat" class="algo-main" type="button" data-algo="left-hat" data-label="üß¢ Chapeau gauche" data-seq="U' L' U L U F U' F'">üß¢ Chapeau gauche</button>
              <button class="algo-step" type="button" data-algo="left-hat" aria-label="Pas a pas"><i class="fa-solid fa-forward-step"></i></button>
            </div>
            <div class="algo-row">
              <button id="right-hat" class="algo-main" type="button" data-algo="right-hat" data-label="üé© Chapeau droite" data-seq="U R U' R' U' F' U F">üé© Chapeau droite</button>
              <button class="algo-step" type="button" data-algo="right-hat" aria-label="Pas a pas"><i class="fa-solid fa-forward-step"></i></button>
            </div>
            <div class="algo-row">
              <button id="yellow-cross" class="algo-main" type="button" data-algo="yellow-cross" data-label="üíõ Croix jaune" data-seq="F R U R' U' F'">üíõ Croix jaune</button>
              <button class="algo-step" type="button" data-algo="yellow-cross" aria-label="Pas a pas"><i class="fa-solid fa-forward-step"></i></button>
            </div>
            <div class="algo-row">
              <button id="chair" class="algo-main" type="button" data-algo="chair" data-label="ü™ë Chaise droite" data-seq="R U2 R' U' R U' R'">ü™ë Chaise droite</button>
              <button class="algo-step" type="button" data-algo="chair" aria-label="Pas a pas"><i class="fa-solid fa-forward-step"></i></button>
            </div>
            <div class="algo-row">
              <button id="left-chair" class="algo-main" type="button" data-algo="left-chair" data-label="ü™ë Chaise gauche" data-seq="L' U2 L U L' U L">ü™ë Chaise gauche</button>
              <button class="algo-step" type="button" data-algo="left-chair" aria-label="Pas a pas"><i class="fa-solid fa-forward-step"></i></button>
            </div>
            <div class="algo-row">
              <button id="right-friends" class="algo-main" type="button" data-algo="right-friends" data-label="ü§ù Amis de droite" data-seq="R U' L' U R' U' L U">ü§ù Amis de droite</button>
              <button class="algo-step" type="button" data-algo="right-friends" aria-label="Pas a pas"><i class="fa-solid fa-forward-step"></i></button>
            </div>
            <div class="algo-row">
              <button id="left-friends" class="algo-main" type="button" data-algo="left-friends" data-label="ü§ù Amis de gauche" data-seq="L' U R U' L U R' U'">ü§ù Amis de gauche</button>
              <button class="algo-step" type="button" data-algo="left-friends" aria-label="Pas a pas"><i class="fa-solid fa-forward-step"></i></button>
            </div>
          </div>
        </aside>
      </section>
    </div>

    <script>
      const COLORS = {
        U: "#f6c445",
        D: "#f4f6fb",
        F: "#ff3b3b",
        R: "#2ecc71",
        L: "#2d6cdf",
        B: "#ff5a1f",
      };

      const FACE_NAMES = ["U", "R", "F", "D", "L", "B"];
      const normalMap = {
        U: { x: 0, y: 1, z: 0 },
        D: { x: 0, y: -1, z: 0 },
        F: { x: 0, y: 0, z: 1 },
        B: { x: 0, y: 0, z: -1 },
        R: { x: 1, y: 0, z: 0 },
        L: { x: -1, y: 0, z: 0 },
      };
      const TWISTED_SEQUENCE = "R U R' U' R' F R2 U' R' U' R U R' F'";

      const cubeEl = document.getElementById("cube");
      const moveButtonsEl = document.getElementById("move-buttons");
      const moveCountEl = document.getElementById("move-count");
      const cubeTypeEl = document.getElementById("cube-type");
      const speedEl = document.getElementById("speed");
      const speedSegmentEl = document.getElementById("speed-segment");

      let cubeSize = 3;
      let coords = [];
      let maxCoord = 1;
      let minCoord = -1;
      let faces = {};
      let stickersByFace = {};
      let stickers = [];
      let moveCount = 0;
      let moveChain = Promise.resolve();
      let moveIndicatorEl = null;

      const faceTransforms = {
        F: "rotateY(0deg) translateZ(calc(var(--size) / 2))",
        B: "rotateY(180deg) translateZ(calc(var(--size) / 2))",
        R: "rotateY(90deg) translateZ(calc(var(--size) / 2))",
        L: "rotateY(-90deg) translateZ(calc(var(--size) / 2))",
        U: "rotateX(90deg) translateZ(calc(var(--size) / 2))",
        D: "rotateX(-90deg) translateZ(calc(var(--size) / 2))",
      };

      const faceVisualSign = {
        U: 1,
        D: -1,
        F: 1,
        B: -1,
        R: -1,
        L: 1,
      };

       function updateMoveCount(delta) {
         moveCount += delta;
         if (moveCountEl) {
           moveCountEl.textContent = moveCount;
         }
         const movesOverlay = document.getElementById("moves-overlay");
         if (movesOverlay) {
           movesOverlay.textContent = `Mouvements: ${moveCount}`;
         }
       }

       function resetMoveCount() {
         moveCount = 0;
         if (moveCountEl) {
           moveCountEl.textContent = 0;
         }
         const movesOverlay = document.getElementById("moves-overlay");
         if (movesOverlay) {
           movesOverlay.textContent = `Mouvements: 0`;
         }
       }

      function buildCube(size) {
        cubeSize = size;
        coords = Array.from({ length: cubeSize }, (_, i) => i - (cubeSize - 1) / 2);
        maxCoord = coords[coords.length - 1];
        minCoord = coords[0];

        faces = {};
        stickersByFace = {};
        cubeEl.innerHTML = "";

        const gap = Math.max(4, 10 - cubeSize * 1.2);
        const pad = Math.max(6, 14 - cubeSize * 1.5);
        cubeEl.style.setProperty("--n", cubeSize);
        cubeEl.style.setProperty("--gap", `${gap}px`);
        cubeEl.style.setProperty("--pad", `${pad}px`);

        FACE_NAMES.forEach((face) => {
          const faceEl = document.createElement("div");
          faceEl.className = "face";
          faceEl.style.transform = faceTransforms[face];
          cubeEl.appendChild(faceEl);
          faces[face] = faceEl;
          stickersByFace[face] = [];

          for (let i = 0; i < cubeSize * cubeSize; i += 1) {
            const sticker = document.createElement("div");
            sticker.className = "sticker";
            faceEl.appendChild(sticker);
            stickersByFace[face].push(sticker);
          }
        });

        if (!moveIndicatorEl) {
          moveIndicatorEl = document.createElement("div");
          moveIndicatorEl.className = "move-indicator";
          moveIndicatorEl.textContent = "R";
        }
      }

      function createSolvedStickers() {
        const result = [];

        const addSticker = (x, y, z, nx, ny, nz, face) => {
          result.push({
            pos: { x, y, z },
            normal: { x: nx, y: ny, z: nz },
            color: COLORS[face],
          });
        };

        coords.forEach((x) => {
          coords.forEach((z) => {
            addSticker(x, maxCoord, z, 0, 1, 0, "U");
            addSticker(x, minCoord, z, 0, -1, 0, "D");
          });
        });

        coords.forEach((x) => {
          coords.forEach((y) => {
            addSticker(x, y, maxCoord, 0, 0, 1, "F");
            addSticker(x, y, minCoord, 0, 0, -1, "B");
          });
        });

        coords.forEach((z) => {
          coords.forEach((y) => {
            addSticker(maxCoord, y, z, 1, 0, 0, "R");
            addSticker(minCoord, y, z, -1, 0, 0, "L");
          });
        });

        return result;
      }

      function rotate90({ x, y, z }, axis, direction) {
        if (axis === "x") {
          return direction > 0
            ? { x, y: -z, z: y }
            : { x, y: z, z: -y };
        }
        if (axis === "y") {
          return direction > 0
            ? { x: z, y, z: -x }
            : { x: -z, y, z: x };
        }
        return direction > 0
          ? { x: -y, y: x, z }
          : { x: y, y: -x, z };
      }

      function isLayer(pos, axis, layerValue) {
        return Math.abs(pos[axis] - layerValue) < 1e-6;
      }

      function degToRad(value) {
        return (value * Math.PI) / 180;
      }

      function rotateVecByView(vec) {
        const rx = degToRad(rotX);
        const ry = degToRad(rotY);
        const cosX = Math.cos(rx);
        const sinX = Math.sin(rx);
        const cosY = Math.cos(ry);
        const sinY = Math.sin(ry);

        const x1 = vec.x;
        const y1 = vec.y * cosX - vec.z * sinX;
        const z1 = vec.y * sinX + vec.z * cosX;

        const x2 = x1 * cosY + z1 * sinY;
        const y2 = y1;
        const z2 = -x1 * sinY + z1 * cosY;

        return { x: x2, y: y2, z: z2 };
      }

      function bestAxisFor(component) {
        const candidates = [
          { axis: "x", vec: { x: 1, y: 0, z: 0 }, pos: "R", neg: "L" },
          { axis: "y", vec: { x: 0, y: 1, z: 0 }, pos: "U", neg: "D" },
          { axis: "z", vec: { x: 0, y: 0, z: 1 }, pos: "F", neg: "B" },
        ];

        let best = null;
        let bestAbs = -Infinity;
        candidates.forEach((cand) => {
          const rotated = rotateVecByView(cand.vec);
          const value = rotated[component];
          const abs = Math.abs(value);
          if (abs > bestAbs) {
            bestAbs = abs;
            best = { ...cand, sign: Math.sign(value) || 1 };
          }
        });
        return best;
      }

      function getViewMapping() {
        return {
          right: bestAxisFor("x"),
          up: bestAxisFor("y"),
          front: bestAxisFor("z"),
        };
      }

      function getFrontFace() {
        const candidates = ["F", "R", "B", "L"];
        let bestFace = "F";
        let bestZ = -Infinity;
        candidates.forEach((face) => {
          const normal = normalMap[face];
          const viewNormal = rotateVecByView(normal);
          if (viewNormal.z > bestZ) {
            bestZ = viewNormal.z;
            bestFace = face;
          }
        });
        return bestFace;
      }

      function axisForFace(face) {
        if (face === "U") return { axis: "y", layer: maxCoord };
        if (face === "D") return { axis: "y", layer: minCoord };
        if (face === "R") return { axis: "x", layer: maxCoord };
        if (face === "L") return { axis: "x", layer: minCoord };
        if (face === "F") return { axis: "z", layer: maxCoord };
        return { axis: "z", layer: minCoord };
      }

      function testPointFor(frontFace, sideFace) {
        const point = { x: 0, y: maxCoord, z: 0 };
        const frontAxis = axisForFace(frontFace);
        const sideAxis = axisForFace(sideFace);
        point[frontAxis.axis] = frontAxis.layer;
        point[sideAxis.axis] = sideAxis.layer;
        return point;
      }

      function chooseTurnSign(frontFace, sideFace) {
        const { axis, layer } = axisForFace(sideFace);
        const point = testPointFor(frontFace, sideFace);
        const plus = rotate90(point, axis, 1);
        const minus = rotate90(point, axis, -1);
        const yPlus = rotateVecByView(plus).y;
        const yMinus = rotateVecByView(minus).y;
        return yPlus >= yMinus ? 1 : -1;
      }

      function parseMove(move) {
        if (typeof move === "object" && move && move.base) {
          return move;
        }
        const base = move[0];
        const modifier = move[1] || "";
        let turns = 1;
        if (modifier === "2") turns = 2;
        if (modifier === "'") turns = -1;
        return { base, turns };
      }

      function resolveViewMove(move) {
        const parsed = parseMove(move);
        if (parsed.base !== "R" && parsed.base !== "L") return parsed;

        const frontFace = getFrontFace();
        const rightMap = { F: "R", R: "B", B: "L", L: "F" };
        const leftMap = { F: "L", L: "B", B: "R", R: "F" };
        const targetFace = parsed.base === "R" ? rightMap[frontFace] : leftMap[frontFace];
        
        // chooseTurnSign returns the direction for the requested side
        const downSign = chooseTurnSign(frontFace, targetFace);
        const finalSign = downSign;

        return { base: targetFace, turns: parsed.turns * finalSign };
      }

      function updateViewIndicator() {
        if (!moveIndicatorEl) return;
        const view = getViewMapping();
        const face = view.front.sign > 0 ? view.front.pos : view.front.neg;
        const faceEl = faces[face];
        if (!faceEl) return;
        if (moveIndicatorEl.parentElement !== faceEl) {
          moveIndicatorEl.remove();
          faceEl.appendChild(moveIndicatorEl);
        }
      }

      function rotateLayer(axis, layerValue, turns) {
        const direction = turns > 0 ? 1 : -1;
        const steps = Math.abs(turns);

        for (let step = 0; step < steps; step += 1) {
          stickers = stickers.map((sticker) => {
            if (!isLayer(sticker.pos, axis, layerValue)) {
              return sticker;
            }

            const newPos = rotate90(sticker.pos, axis, direction);
            const newNormal = rotate90(sticker.normal, axis, direction);
            return {
              ...sticker,
              pos: newPos,
              normal: newNormal,
            };
          });
        }
      }

      function applyMoveState(move) {
        const resolved = resolveViewMove(move);
        const { base, turns } = resolved;

        switch (base) {
          case "U":
            rotateLayer("y", maxCoord, -turns);
            break;
          case "D":
            rotateLayer("y", minCoord, turns);
            break;
          case "R":
            rotateLayer("x", maxCoord, turns);
            break;
          case "L":
            rotateLayer("x", minCoord, -turns);
            break;
          case "F":
            rotateLayer("z", maxCoord, -turns);
            break;
          case "B":
            rotateLayer("z", minCoord, turns);
            break;
          default:
            break;
        }

        return Math.abs(turns);
      }

      function parseSequence(sequence) {
        return sequence
          .trim()
          .split(/\s+/)
          .filter(Boolean)
          .flatMap((token) => {
            const match = token.match(/^([URFDLB])([2']?)$/);
            return match ? [match[1] + match[2]] : [];
          });
      }

      function getFaceIndex(face, pos) {
        const { x, y, z } = pos;
        const idx = (value) => coords.indexOf(value);

        if (face === "U") {
          return idx(z) * cubeSize + idx(x);
        }
        if (face === "D") {
          return (cubeSize - 1 - idx(z)) * cubeSize + idx(x);
        }
        if (face === "F") {
          return (cubeSize - 1 - idx(y)) * cubeSize + idx(x);
        }
        if (face === "B") {
          return (cubeSize - 1 - idx(y)) * cubeSize + (cubeSize - 1 - idx(x));
        }
        if (face === "R") {
          return (cubeSize - 1 - idx(y)) * cubeSize + (cubeSize - 1 - idx(z));
        }
        return (cubeSize - 1 - idx(y)) * cubeSize + idx(z);
      }

      function render() {
        const faceColors = {
          U: Array(cubeSize * cubeSize).fill("#111"),
          D: Array(cubeSize * cubeSize).fill("#111"),
          F: Array(cubeSize * cubeSize).fill("#111"),
          B: Array(cubeSize * cubeSize).fill("#111"),
          L: Array(cubeSize * cubeSize).fill("#111"),
          R: Array(cubeSize * cubeSize).fill("#111"),
        };

        stickers.forEach((sticker) => {
          const n = sticker.normal;
          let face = "F";
          if (n.y === 1) face = "U";
          else if (n.y === -1) face = "D";
          else if (n.z === 1) face = "F";
          else if (n.z === -1) face = "B";
          else if (n.x === 1) face = "R";
          else if (n.x === -1) face = "L";

          const index = getFaceIndex(face, sticker.pos);
          faceColors[face][index] = sticker.color;
        });

        FACE_NAMES.forEach((face) => {
          stickersByFace[face].forEach((stickerEl, index) => {
            stickerEl.style.background = faceColors[face][index];
          });
        });
      }

      function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      async function animateFace(face, turns) {
        const faceEl = faces[face];
        if (!faceEl) return;
        const duration = Number(speedEl.value);
        const angle = 90 * turns * faceVisualSign[face];
        const base = faceTransforms[face];

        faceEl.style.transition = `transform ${duration}ms ease-in-out`;
        await new Promise((resolve) => requestAnimationFrame(resolve));
        faceEl.style.transform = `${base} rotateZ(${angle}deg)`;
        await sleep(duration);
        faceEl.style.transition = "none";
        faceEl.style.transform = base;
      }

      function enqueueMove(move) {
        moveChain = moveChain.then(async () => {
          try {
            const resolved = resolveViewMove(move);
            const { base, turns } = resolved;

            await animateFace(base, turns);
            const delta = applyMoveState(move);
            updateMoveCount(delta);
            render();
          } catch (e) {
            console.error("Erreur lors du mouvement :", e);
          }
        });
      }

      function enqueueMoves(moves) {
        moves.forEach((move) => enqueueMove(move));
      }

      function resetState() {
        stickers = createSolvedStickers();
        render();
        resetMoveCount();
      }

      function scramble() {
        resetMoveCount();
        const moves = ["U", "D", "L", "R", "F", "B"];
        const modifiers = ["", "'", "2"];
        const sequence = [];
        let lastMove = null;

        for (let i = 0; i < 20; i += 1) {
          let move = moves[Math.floor(Math.random() * moves.length)];
          while (move === lastMove) {
            move = moves[Math.floor(Math.random() * moves.length)];
          }
          lastMove = move;
          const mod = modifiers[Math.floor(Math.random() * modifiers.length)];
          sequence.push(move + mod);
        }

        enqueueMoves(sequence);
      }

      function applySequenceInstant(sequence) {
        parseSequence(sequence).forEach((move) => {
          applyMoveState(move);
        });
        render();
      }

      const moveList = [
        "R",
        "R'",
        "R2",
        "L",
        "L'",
        "L2",
        "U",
        "U'",
        "U2",
        "D",
        "D'",
        "D2",
        "F",
        "F'",
        "F2",
        "B",
        "B'",
        "B2",
      ];

      function moveIcon(move) {
        const isDouble = move.includes("2");
        const isPrime = move.includes("'");
        const arrow = isPrime ? "‚Ü∫" : "‚Üª";
        const label = isDouble ? "2" : "";
        return `
          <svg viewBox="0 0 48 48" aria-hidden="true">
            <defs>
              <linearGradient id="g1" x1="0" x2="1" y1="0" y2="1">
                <stop offset="0" stop-color="#47526a" />
                <stop offset="1" stop-color="#1d2433" />
              </linearGradient>
            </defs>
            <path d="M10 18 L24 10 L38 18 L24 26 Z" fill="url(#g1)" stroke="#90a0c0" stroke-width="1.2" />
            <path d="M10 18 L10 34 L24 42 L24 26 Z" fill="#2a3348" stroke="#90a0c0" stroke-width="1.2" />
            <path d="M38 18 L38 34 L24 42 L24 26 Z" fill="#1d2433" stroke="#90a0c0" stroke-width="1.2" />
            <text x="31" y="16" font-size="12" fill="#f7b32b" font-family="Space Grotesk, sans-serif">${label}</text>
            <text x="6" y="44" font-size="16" fill="#f7b32b" font-family="Space Grotesk, sans-serif">${arrow}</text>
          </svg>
        `;
      }

      function rebuildMoveButtons() {
        moveButtonsEl.innerHTML = "";
        moveList.forEach((move) => {
          const button = document.createElement("button");
          const label = document.createElement("span");
          label.textContent = move;
          const icon = document.createElement("span");
          icon.className = "move-icon";
          icon.innerHTML = moveIcon(move);
          button.appendChild(label);
          button.appendChild(icon);
          button.addEventListener("click", () => enqueueMove(move));
          moveButtonsEl.appendChild(button);
        });
      }

      const algoSequences = {
        sexy: ["R", "U", "R'", "U'"],
        "left-hat": ["U'", "L'", "U", "L", "U", "F", "U'", "F'"],
        "right-hat": ["U", "R", "U'", "R'", "U'", "F'", "U", "F"],
        "yellow-cross": ["F", "R", "U", "R'", "U'", "F'"],
        chair: ["R", "U2", "R'", "U'", "R", "U'", "R'"],
        "left-chair": ["L'", "U2", "L", "U", "L'", "U", "L"],
        "right-friends": ["R", "U'", "L'", "U", "R'", "U'", "L", "U"],
        "left-friends": ["L'", "U", "R", "U'", "L", "U", "R'", "U'"],
      };
      const algoSteps = Object.keys(algoSequences).reduce((acc, key) => {
        acc[key] = 0;
        return acc;
      }, {});
      const algoSpans = {};
      let notationMode = "standard";

      document.querySelectorAll(".algo-main").forEach((button) => {
        const label = button.dataset.label || "";
        const sequence = (button.dataset.seq || "").trim().split(/\s+/).filter(Boolean);
        const seqSpans = sequence
          .map((move) => {
            const face = move[0] || "";
            return `<span class="move-step" data-move="${move}" data-face="${face}">${move}</span>`;
          })
          .join(" ");
        button.innerHTML = `<span class="algo-label">${label} ¬∑ ${seqSpans}</span>`;
        if (button.dataset.algo) {
          algoSpans[button.dataset.algo] = Array.from(button.querySelectorAll(".move-step"));
        }
      });
      applyNotation(notationMode);

      function formatMoveDisplay(move, mode) {
        const base = move[0] || "";
        const modifier = move[1] || "";
        if (modifier === "2") return `${base}2`;
        if (mode === "lowercase") {
          return modifier === "'" ? base.toLowerCase() : base;
        }
        if (mode === "arrows") {
          if (base === "U") {
            return modifier === "'" ? `${base}‚Üê` : `${base}‚Üí`;
          }
          return modifier === "'" ? `${base}‚Üì` : `${base}‚Üë`;
        }
        return modifier === "'" ? `${base}'` : base;
      }

      function applyNotation(mode) {
        notationMode = mode;
        document.documentElement.classList.toggle("notation-lowercase", mode === "lowercase");
        Object.values(algoSpans).forEach((spans) => {
          spans.forEach((span) => {
            span.textContent = formatMoveDisplay(span.dataset.move || "", mode);
          });
        });
      }

      function highlightAlgoStep(key, index) {
        const spans = algoSpans[key];
        if (!spans || !spans.length) return;
        spans.forEach((span, idx) => {
          span.classList.toggle("active", idx === index);
        });
      }

      function clearAlgoHighlight(key) {
        const spans = algoSpans[key];
        if (!spans) return;
        spans.forEach((span) => span.classList.remove("active"));
      }

      function stepAlgo(key) {
        const sequence = algoSequences[key];
        if (!sequence) return;
        const index = algoSteps[key] % sequence.length;
        highlightAlgoStep(key, index);
        algoSteps[key] = (index + 1) % sequence.length;
        enqueueMove(sequence[index]);
      }

      function resetAlgo(key) {
        if (!(key in algoSteps)) return;
        algoSteps[key] = 0;
        clearAlgoHighlight(key);
      }

      function resetAllAlgos() {
        Object.keys(algoSteps).forEach((key) => resetAlgo(key));
      }

      document.querySelectorAll(".algo-step").forEach((button) => {
        button.addEventListener("click", () => {
          stepAlgo(button.dataset.algo);
        });
      });

      const notationEl = document.getElementById("algo-notation");
      if (notationEl) {
        notationEl.querySelectorAll("button").forEach((button) => {
          button.addEventListener("click", () => {
            notationEl.querySelectorAll("button").forEach((b) => b.classList.remove("active"));
            button.classList.add("active");
            applyNotation(button.dataset.notation || "standard");
          });
        });
      }

      document.getElementById("apply-sequence").addEventListener("click", () => {
        const input = document.getElementById("sequence-input");
        const moves = parseSequence(input.value);
        enqueueMoves(moves);
      });

      document.getElementById("reset").addEventListener("click", () => {
        resetState();
        resetAllAlgos();
      });

      document.getElementById("scramble").addEventListener("click", () => {
        scramble();
      });

      document.getElementById("sexy-move").addEventListener("click", () => {
        resetAlgo("sexy");
        enqueueMoves(algoSequences.sexy);
      });
      document.getElementById("left-hat").addEventListener("click", () => {
        resetAlgo("left-hat");
        enqueueMoves(algoSequences["left-hat"]);
      });

      document.getElementById("right-hat").addEventListener("click", () => {
        resetAlgo("right-hat");
        enqueueMoves(algoSequences["right-hat"]);
      });

      document.getElementById("yellow-cross").addEventListener("click", () => {
        resetAlgo("yellow-cross");
        enqueueMoves(algoSequences["yellow-cross"]);
      });

      document.getElementById("chair").addEventListener("click", () => {
        resetAlgo("chair");
        enqueueMoves(algoSequences.chair);
      });

      document.getElementById("left-chair").addEventListener("click", () => {
        resetAlgo("left-chair");
        enqueueMoves(algoSequences["left-chair"]);
      });

      document.getElementById("right-friends").addEventListener("click", () => {
        resetAlgo("right-friends");
        enqueueMoves(algoSequences["right-friends"]);
      });

      document.getElementById("left-friends").addEventListener("click", () => {
        resetAlgo("left-friends");
        enqueueMoves(algoSequences["left-friends"]);
      });

      cubeTypeEl.addEventListener("change", () => {
        const value = cubeTypeEl.value;
        let size = 3;
        let preset = null;
        if (value === "2") size = 2;
        if (value === "3") size = 3;
        if (value === "4") size = 4;
        if (value === "3-twisted") {
          size = 3;
          preset = TWISTED_SEQUENCE;
        }

        buildCube(size);
        stickers = createSolvedStickers();
        render();
        resetMoveCount();
        if (preset) {
          applySequenceInstant(preset);
        }
      });

      rebuildMoveButtons();
      buildCube(cubeSize);
      resetState();

      if (speedSegmentEl) {
        speedSegmentEl.querySelectorAll("button").forEach((button) => {
          button.addEventListener("click", () => {
            speedSegmentEl.querySelectorAll("button").forEach((b) => b.classList.remove("active"));
            button.classList.add("active");
            speedEl.value = button.dataset.speed;
          });
        });
      }

      const viewport = document.getElementById("viewport");
      let isDragging = false;
      let lastX = 0;
      let lastY = 0;
       let rotX = -15;
       let rotY = -15;

       function updateCubeRotation() {
         cubeEl.style.transform = `rotateX(${rotX}deg) rotateY(${rotY}deg)`;
         const coordsOverlay = document.getElementById("coords-overlay");
         if (coordsOverlay) {
           coordsOverlay.textContent = `rotX: ${Math.round(rotX)}, rotY: ${Math.round(rotY)}`;
         }
         updateViewIndicator();
       }

      viewport.addEventListener("pointerdown", (event) => {
        isDragging = true;
        lastX = event.clientX;
        lastY = event.clientY;
        viewport.setPointerCapture(event.pointerId);
      });

      viewport.addEventListener("pointermove", (event) => {
        if (!isDragging) return;
        const dx = event.clientX - lastX;
        const dy = event.clientY - lastY;
        rotY += dx * 0.5;
        rotX -= dy * 0.5;
        rotX = Math.max(-80, Math.min(80, rotX));
        lastX = event.clientX;
        lastY = event.clientY;
        updateCubeRotation();
      });

      viewport.addEventListener("pointerup", () => {
        isDragging = false;
      });

      viewport.addEventListener("pointerleave", () => {
        isDragging = false;
      });

      updateCubeRotation();
    </script>
  </body>
</html>
