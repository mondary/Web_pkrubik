<!doctype html>
<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Rubik's Cube 3x3 Simulator</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />
    <style>
      :root {
        --bg: #0e1014;
        --panel: #151922;
        --panel-2: #1b2130;
        --text: #f4f6fb;
        --muted: #b9c0d1;
        --accent: #f7b32b;
        --face-u: #f6c445;
        --face-d: #f4f6fb;
        --face-f: #ff3b3b;
        --face-r: #2ecc71;
        --face-l: #2d6cdf;
        --face-b: #ff7a30;
        --sticker-border: #111;
        --size: 240px;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Space Grotesk", "Segoe UI", sans-serif;
        background: radial-gradient(circle at 20% 20%, #1a2030 0, transparent 45%),
          radial-gradient(circle at 80% 10%, #252c40 0, transparent 40%),
          var(--bg);
        color: var(--text);
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 32px 16px;
      }

      .app {
        width: min(1100px, 100%);
        display: grid;
        gap: 24px;
      }

      header {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      h1 {
        font-size: clamp(26px, 4vw, 42px);
        margin: 0;
        letter-spacing: -0.02em;
      }

      p {
        margin: 0;
        color: var(--muted);
        line-height: 1.5;
      }

      .layout {
        display: grid;
        gap: 24px;
        grid-template-columns: minmax(280px, 1.1fr) minmax(260px, 0.9fr);
        align-items: start;
      }

      .stage {
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.06), transparent);
        border-radius: 24px;
        padding: 24px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        display: grid;
        gap: 18px;
      }

      .viewport {
        perspective: 900px;
        width: 100%;
        aspect-ratio: 1 / 1;
        display: grid;
        place-items: center;
      }

      .cube {
        width: var(--size);
        height: var(--size);
        position: relative;
        transform-style: preserve-3d;
        transition: transform 0.2s ease-out;
        --n: 3;
        --gap: 6px;
        --pad: 10px;
      }

      .face {
        position: absolute;
        width: var(--size);
        height: var(--size);
        display: grid;
        grid-template-columns: repeat(var(--n), 1fr);
        grid-template-rows: repeat(var(--n), 1fr);
        gap: var(--gap);
        padding: var(--pad);
        background: rgba(0, 0, 0, 0.3);
        border-radius: 18px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        backface-visibility: hidden;
        overflow: visible;
      }

      .sticker {
        border-radius: 10px;
        border: 2px solid var(--sticker-border);
        box-shadow: inset 0 0 12px rgba(0, 0, 0, 0.35);
        transition: background-color 0.15s ease-out;
      }

      .sticker.is-hidden {
        opacity: 0;
      }

      .slice-group {
        position: absolute;
        inset: 0;
        transform-style: preserve-3d;
        pointer-events: none;
      }

      .slice-face {
        background: transparent;
        border: none;
        box-shadow: none;
      }

      .slice-sticker {
        transition: none;
      }

      .move-indicator {
        position: absolute;
        top: 6px;
        right: 6px;
        width: 22px;
        height: 22px;
        border-radius: 6px;
        background: rgba(15, 19, 32, 0.85);
        border: 1px solid rgba(255, 255, 255, 0.12);
        display: grid;
        place-items: center;
        font-size: 12px;
        font-weight: 700;
        color: #f4f6fb;
        pointer-events: none;
      }

      .panel {
        background: var(--panel);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 24px;
        padding: 22px;
        display: grid;
        gap: 18px;
      }

      .moves {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 10px;
      }

      button {
        border: none;
        padding: 10px 12px;
        border-radius: 12px;
        background: var(--panel-2);
        color: var(--text);
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.12s ease, background 0.12s ease;
        display: inline-flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        text-align: left;
      }

      button:hover {
        background: #27314a;
        transform: translateY(-1px);
      }

      .move-icon {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        opacity: 0.9;
      }

      .move-icon svg {
        width: 30px;
        height: 30px;
      }

      .action-row {
        display: grid;
        gap: 10px;
      }

      .algo-label {
        display: inline-flex;
        gap: 6px;
        align-items: center;
        flex-wrap: wrap;
      }

      .icon-yellow-cross {
        width: 18px;
        height: 18px;
        display: inline-flex;
        vertical-align: middle;
      }

      .icon-hat {
        width: 18px;
        height: 18px;
        display: inline-flex;
        vertical-align: middle;
        color: #f4f6fb;
      }

      .icon-hat.mirror {
        transform: scaleX(-1);
      }

      .move-step {
        padding: 0 2px;
        border-radius: 6px;
        color: var(--muted);
      }

      .notation-lowercase .move-step {
        font-family: "Georgia", "Times New Roman", serif;
      }

      .move-step.active {
        background: rgba(247, 179, 43, 0.18);
      }

      .move-step.active[data-face="U"] {
        color: var(--face-u);
      }

      .move-step.active[data-face="D"] {
        color: var(--face-d);
      }

      .move-step.active[data-face="F"] {
        color: var(--face-f);
      }

      .move-step.active[data-face="R"] {
        color: var(--face-r);
      }

      .move-step.active[data-face="L"] {
        color: var(--face-l);
      }

      .move-step.active[data-face="B"] {
        color: var(--face-b);
      }

      .algo-row {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 8px;
        align-items: stretch;
      }

      .algo-notation {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }

      .algo-notation button {
        justify-content: center;
        padding: 6px 10px;
        font-size: 13px;
      }

      .algo-step {
        white-space: nowrap;
        justify-content: center;
      }

      input[type="text"],
      select {
        width: 100%;
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        background: #0f1320;
        color: var(--text);
        font-size: 14px;
      }

      .segmented {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 6px;
        background: #0f1320;
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 12px;
        padding: 4px;
      }

      .segmented button {
        padding: 8px 10px;
        border-radius: 8px;
        background: transparent;
        font-size: 13px;
      }

      .segmented button.active {
        background: #27314a;
      }

      .controls-row {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 10px;
        align-items: center;
      }

      .icon-actions {
        display: grid;
        grid-auto-flow: column;
        gap: 8px;
      }

      .icon-actions button {
        width: 36px;
        height: 36px;
        border-radius: 10px;
        justify-content: center;
        font-size: 16px;
        color: #f4f6fb;
      }

      .notation-row {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 8px;
        align-items: center;
      }

      .stat {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        padding: 10px 12px;
        border-radius: 12px;
        background: #0f1320;
        border: 1px solid rgba(255, 255, 255, 0.08);
      }

      .small {
        font-size: 13px;
        color: var(--muted);
      }

      .pill {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 10px;
        border-radius: 999px;
        background: rgba(247, 179, 43, 0.15);
        color: var(--accent);
        font-weight: 600;
        font-size: 12px;
      }

      .coords-overlay {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: #f4f6fb;
        padding: 4px 8px;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 600;
        pointer-events: none;
      }

      .moves-overlay {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: #f4f6fb;
        padding: 4px 8px;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 600;
        pointer-events: none;
      }

      @media (max-width: 900px) {
        .layout {
          grid-template-columns: 1fr;
        }

        .cube {
          width: min(72vw, 260px);
          height: min(72vw, 260px);
        }
      }
    </style>
  </head>
  <body>
    <div class="app">
       <header>
         <h1>Simulateur Rubik's Cube</h1>
         <p>Faites tourner le cube, appliquez des mouvements et saisissez vos algorithmes.</p>
       </header>

      <section class="layout">
         <div class="stage">
             <div class="viewport" id="viewport">
              <div class="cube" id="cube"></div>
              <div class="coords-overlay" id="coords-overlay">rotX: 0, rotY: 0</div>
              <div class="moves-overlay" id="moves-overlay">Mouvements: 0</div>
            </div>
         </div>

        <aside class="panel">
           <div class="action-row">
             <strong>Cube</strong>
           <select id="cube-type">
             <option value="2">2x2</option>
             <option value="3" selected>3x3</option>
             <option value="3-twisted">3x3 twisted</option>
             <option value="4">4x4</option>
           </select>
           <div class="controls-row">
             <div class="segmented" id="speed-segment">
               <button type="button" data-speed="600" aria-label="Lent">üê¢</button>
               <button type="button" data-speed="350" class="active" aria-label="Normal">üêá</button>
               <button type="button" data-speed="180" aria-label="Rapide">‚ö°</button>
             </div>
             <div class="icon-actions">
               <button type="button" id="reset" aria-label="Reinitialiser"><i class="fa-solid fa-rotate-left"></i></button>
               <button type="button" id="scramble" aria-label="Melanger"><i class="fa-solid fa-shuffle"></i></button>
             </div>
           </div>
           <input type="hidden" id="speed" value="350" />
          </div>

          <div class="action-row">
            <strong>Notation</strong>
            <div class="notation-row">
              <input id="sequence-input" type="text" placeholder="R U R' U'" />
              <button id="apply-sequence" aria-label="Appliquer la sequence"><i class="fa-solid fa-play"></i></button>
            </div>
          </div>

          <div class="action-row">
            <strong>Mouvements rapides</strong>
            <div class="moves" id="move-buttons"></div>
            <div class="segmented algo-notation" id="algo-notation">
              <button type="button" data-notation="standard" class="active" aria-label="Notation standard">R / R'</button>
              <button type="button" data-notation="lowercase" aria-label="Notation minuscule">R / r</button>
              <button type="button" data-notation="arrows" aria-label="Notation fleches">R‚Üë / R‚Üì</button>
            </div>
            <div class="algo-row">
              <button id="sexy-move" class="algo-main" type="button" data-algo="sexy" data-label="üî• Sexy move" data-seq="R U R' U'">üî• Sexy move</button>
              <button class="algo-step" type="button" data-algo="sexy" aria-label="Pas a pas"><i class="fa-solid fa-forward-step"></i></button>
            </div>
            <div class="algo-row">
              <button id="left-hat" class="algo-main" type="button" data-algo="left-hat" data-label='<svg class="icon-hat" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" aria-hidden="true"><path fill="currentColor" d="M405.5 349.6C439.2 349.6 487.8 342.7 487.8 302.6C488 295.9 488.7 300.8 466.9 206.4C462.3 187.3 458.2 178.6 424.6 161.8C398.5 148.5 341.7 126.4 324.9 126.4C309.2 126.4 304.7 146.6 286 146.6C268 146.6 254.7 131.5 237.9 131.5C221.8 131.5 211.2 142.5 203.1 165.1C175.6 242.7 176.8 239.4 177 243.4C177 268.2 274.6 349.5 405.5 349.5zM493 318.8C497.7 340.8 497.7 343.1 497.7 346C497.7 383.7 455.4 404.6 399.7 404.6C274 404.7 163.8 331 163.8 282.3C163.8 275.5 165.2 268.8 167.9 262.6C122.7 264.9 64.1 272.9 64.1 324.6C64.1 409.3 264.7 513.6 423.6 513.6C545.4 513.6 576.1 458.5 576.1 415C576.1 380.8 546.5 342 493.2 318.8z"/></svg> Chapeau gauche' data-seq="U' L' U L U F U' F'"><svg class="icon-hat" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" aria-hidden="true"><path fill="currentColor" d="M405.5 349.6C439.2 349.6 487.8 342.7 487.8 302.6C488 295.9 488.7 300.8 466.9 206.4C462.3 187.3 458.2 178.6 424.6 161.8C398.5 148.5 341.7 126.4 324.9 126.4C309.2 126.4 304.7 146.6 286 146.6C268 146.6 254.7 131.5 237.9 131.5C221.8 131.5 211.2 142.5 203.1 165.1C175.6 242.7 176.8 239.4 177 243.4C177 268.2 274.6 349.5 405.5 349.5zM493 318.8C497.7 340.8 497.7 343.1 497.7 346C497.7 383.7 455.4 404.6 399.7 404.6C274 404.7 163.8 331 163.8 282.3C163.8 275.5 165.2 268.8 167.9 262.6C122.7 264.9 64.1 272.9 64.1 324.6C64.1 409.3 264.7 513.6 423.6 513.6C545.4 513.6 576.1 458.5 576.1 415C576.1 380.8 546.5 342 493.2 318.8z"/></svg> Chapeau gauche</button>
              <button class="algo-step" type="button" data-algo="left-hat" aria-label="Pas a pas"><i class="fa-solid fa-forward-step"></i></button>
            </div>
            <div class="algo-row">
              <button id="right-hat" class="algo-main" type="button" data-algo="right-hat" data-label='<svg class="icon-hat mirror" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" aria-hidden="true"><path fill="currentColor" d="M405.5 349.6C439.2 349.6 487.8 342.7 487.8 302.6C488 295.9 488.7 300.8 466.9 206.4C462.3 187.3 458.2 178.6 424.6 161.8C398.5 148.5 341.7 126.4 324.9 126.4C309.2 126.4 304.7 146.6 286 146.6C268 146.6 254.7 131.5 237.9 131.5C221.8 131.5 211.2 142.5 203.1 165.1C175.6 242.7 176.8 239.4 177 243.4C177 268.2 274.6 349.5 405.5 349.5zM493 318.8C497.7 340.8 497.7 343.1 497.7 346C497.7 383.7 455.4 404.6 399.7 404.6C274 404.7 163.8 331 163.8 282.3C163.8 275.5 165.2 268.8 167.9 262.6C122.7 264.9 64.1 272.9 64.1 324.6C64.1 409.3 264.7 513.6 423.6 513.6C545.4 513.6 576.1 458.5 576.1 415C576.1 380.8 546.5 342 493.2 318.8z"/></svg> Chapeau droite' data-seq="U R U' R' U' F' U F"><svg class="icon-hat mirror" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" aria-hidden="true"><path fill="currentColor" d="M405.5 349.6C439.2 349.6 487.8 342.7 487.8 302.6C488 295.9 488.7 300.8 466.9 206.4C462.3 187.3 458.2 178.6 424.6 161.8C398.5 148.5 341.7 126.4 324.9 126.4C309.2 126.4 304.7 146.6 286 146.6C268 146.6 254.7 131.5 237.9 131.5C221.8 131.5 211.2 142.5 203.1 165.1C175.6 242.7 176.8 239.4 177 243.4C177 268.2 274.6 349.5 405.5 349.5zM493 318.8C497.7 340.8 497.7 343.1 497.7 346C497.7 383.7 455.4 404.6 399.7 404.6C274 404.7 163.8 331 163.8 282.3C163.8 275.5 165.2 268.8 167.9 262.6C122.7 264.9 64.1 272.9 64.1 324.6C64.1 409.3 264.7 513.6 423.6 513.6C545.4 513.6 576.1 458.5 576.1 415C576.1 380.8 546.5 342 493.2 318.8z"/></svg> Chapeau droite</button>
              <button class="algo-step" type="button" data-algo="right-hat" aria-label="Pas a pas"><i class="fa-solid fa-forward-step"></i></button>
            </div>
            <div class="algo-row">
              <button id="yellow-cross" class="algo-main" type="button" data-algo="yellow-cross" data-label='<svg class="icon-yellow-cross" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" aria-hidden="true"><path fill="#f6c445" d="M304 64C277.5 64 256 85.5 256 112L256 192L176 192C149.5 192 128 213.5 128 240L128 272C128 298.5 149.5 320 176 320L256 320L256 528C256 554.5 277.5 576 304 576L336 576C362.5 576 384 554.5 384 528L384 320L464 320C490.5 320 512 298.5 512 272L512 240C512 213.5 490.5 192 464 192L384 192L384 112C384 85.5 362.5 64 336 64L304 64z"/></svg> Croix jaune' data-seq="F R U R' U' F'"><svg class="icon-yellow-cross" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" aria-hidden="true"><path fill="#f6c445" d="M304 64C277.5 64 256 85.5 256 112L256 192L176 192C149.5 192 128 213.5 128 240L128 272C128 298.5 149.5 320 176 320L256 320L256 528C256 554.5 277.5 576 304 576L336 576C362.5 576 384 554.5 384 528L384 320L464 320C490.5 320 512 298.5 512 272L512 240C512 213.5 490.5 192 464 192L384 192L384 112C384 85.5 362.5 64 336 64L304 64z"/></svg> Croix jaune</button>
              <button class="algo-step" type="button" data-algo="yellow-cross" aria-label="Pas a pas"><i class="fa-solid fa-forward-step"></i></button>
            </div>
            <div class="algo-row">
              <button id="chair" class="algo-main" type="button" data-algo="chair" data-label="ü™ë Chaise droite" data-seq="R U2 R' U' R U' R'">ü™ë Chaise droite</button>
              <button class="algo-step" type="button" data-algo="chair" aria-label="Pas a pas"><i class="fa-solid fa-forward-step"></i></button>
            </div>
            <div class="algo-row">
              <button id="left-chair" class="algo-main" type="button" data-algo="left-chair" data-label="ü™ë Chaise gauche" data-seq="L' U2 L U L' U L">ü™ë Chaise gauche</button>
              <button class="algo-step" type="button" data-algo="left-chair" aria-label="Pas a pas"><i class="fa-solid fa-forward-step"></i></button>
            </div>
            <div class="algo-row">
              <button id="right-friends" class="algo-main" type="button" data-algo="right-friends" data-label="ü§ù Amis de droite" data-seq="R U' L' U R' U' L U">ü§ù Amis de droite</button>
              <button class="algo-step" type="button" data-algo="right-friends" aria-label="Pas a pas"><i class="fa-solid fa-forward-step"></i></button>
            </div>
            <div class="algo-row">
              <button id="left-friends" class="algo-main" type="button" data-algo="left-friends" data-label="ü§ù Amis de gauche" data-seq="L' U R U' L U R' U'">ü§ù Amis de gauche</button>
              <button class="algo-step" type="button" data-algo="left-friends" aria-label="Pas a pas"><i class="fa-solid fa-forward-step"></i></button>
            </div>
          </div>
        </aside>
      </section>
    </div>

    <script>
      const COLORS = {
        U: "#f6c445",
        D: "#f4f6fb",
        F: "#ff3b3b",
        R: "#2ecc71",
        L: "#2d6cdf",
        B: "#ff5a1f",
      };

      const FACE_NAMES = ["U", "R", "F", "D", "L", "B"];
      const normalMap = {
        U: { x: 0, y: 1, z: 0 },
        D: { x: 0, y: -1, z: 0 },
        F: { x: 0, y: 0, z: 1 },
        B: { x: 0, y: 0, z: -1 },
        R: { x: 1, y: 0, z: 0 },
        L: { x: -1, y: 0, z: 0 },
      };
      const TWISTED_SEQUENCE = "R U R' U' R' F R2 U' R' U' R U R' F'";

      const cubeEl = document.getElementById("cube");
      const moveButtonsEl = document.getElementById("move-buttons");
      const moveCountEl = document.getElementById("move-count");
      const cubeTypeEl = document.getElementById("cube-type");
      const speedEl = document.getElementById("speed");
      const speedSegmentEl = document.getElementById("speed-segment");

      let cubeSize = 3;
      let coords = [];
      let maxCoord = 1;
      let minCoord = -1;
      let faces = {};
      let stickersByFace = {};
      let stickers = [];
      let moveCount = 0;
      let moveChain = Promise.resolve();
      let moveIndicatorEl = null;

      const faceTransforms = {
        F: "rotateY(0deg) translateZ(calc(var(--size) / 2))",
        B: "rotateY(180deg) translateZ(calc(var(--size) / 2))",
        R: "rotateY(90deg) translateZ(calc(var(--size) / 2))",
        L: "rotateY(-90deg) translateZ(calc(var(--size) / 2))",
        U: "rotateX(90deg) translateZ(calc(var(--size) / 2))",
        D: "rotateX(-90deg) translateZ(calc(var(--size) / 2))",
      };

      const faceVisualSign = {
        U: 1,
        D: -1,
        F: 1,
        B: -1,
        R: -1,
        L: 1,
      };

       function updateMoveCount(delta) {
         moveCount += delta;
         if (moveCountEl) {
           moveCountEl.textContent = moveCount;
         }
         const movesOverlay = document.getElementById("moves-overlay");
         if (movesOverlay) {
           movesOverlay.textContent = `Mouvements: ${moveCount}`;
         }
       }

       function resetMoveCount() {
         moveCount = 0;
         if (moveCountEl) {
           moveCountEl.textContent = 0;
         }
         const movesOverlay = document.getElementById("moves-overlay");
         if (movesOverlay) {
           movesOverlay.textContent = `Mouvements: 0`;
         }
       }

      function buildCube(size) {
        cubeSize = size;
        coords = Array.from({ length: cubeSize }, (_, i) => i - (cubeSize - 1) / 2);
        maxCoord = coords[coords.length - 1];
        minCoord = coords[0];

        faces = {};
        stickersByFace = {};
        cubeEl.innerHTML = "";

        const gap = Math.max(4, 10 - cubeSize * 1.2);
        const pad = Math.max(6, 14 - cubeSize * 1.5);
        cubeEl.style.setProperty("--n", cubeSize);
        cubeEl.style.setProperty("--gap", `${gap}px`);
        cubeEl.style.setProperty("--pad", `${pad}px`);

        FACE_NAMES.forEach((face) => {
          const faceEl = document.createElement("div");
          faceEl.className = "face";
          faceEl.style.transform = faceTransforms[face];
          cubeEl.appendChild(faceEl);
          faces[face] = faceEl;
          stickersByFace[face] = [];

          for (let i = 0; i < cubeSize * cubeSize; i += 1) {
            const sticker = document.createElement("div");
            sticker.className = "sticker";
            faceEl.appendChild(sticker);
            stickersByFace[face].push(sticker);
          }
        });

        if (!moveIndicatorEl) {
          moveIndicatorEl = document.createElement("div");
          moveIndicatorEl.className = "move-indicator";
          moveIndicatorEl.textContent = "R";
        }
      }

      function createSolvedStickers() {
        const result = [];

        const addSticker = (x, y, z, nx, ny, nz, face) => {
          result.push({
            pos: { x, y, z },
            normal: { x: nx, y: ny, z: nz },
            color: COLORS[face],
          });
        };

        coords.forEach((x) => {
          coords.forEach((z) => {
            addSticker(x, maxCoord, z, 0, 1, 0, "U");
            addSticker(x, minCoord, z, 0, -1, 0, "D");
          });
        });

        coords.forEach((x) => {
          coords.forEach((y) => {
            addSticker(x, y, maxCoord, 0, 0, 1, "F");
            addSticker(x, y, minCoord, 0, 0, -1, "B");
          });
        });

        coords.forEach((z) => {
          coords.forEach((y) => {
            addSticker(maxCoord, y, z, 1, 0, 0, "R");
            addSticker(minCoord, y, z, -1, 0, 0, "L");
          });
        });

        return result;
      }

      function rotate90({ x, y, z }, axis, direction) {
        if (axis === "x") {
          return direction > 0
            ? { x, y: -z, z: y }
            : { x, y: z, z: -y };
        }
        if (axis === "y") {
          return direction > 0
            ? { x: z, y, z: -x }
            : { x: -z, y, z: x };
        }
        return direction > 0
          ? { x: -y, y: x, z }
          : { x: y, y: -x, z };
      }

      function isLayer(pos, axis, layerValue) {
        return Math.abs(pos[axis] - layerValue) < 1e-6;
      }

      function degToRad(value) {
        return (value * Math.PI) / 180;
      }

      function rotateVecByView(vec) {
        const rx = degToRad(rotX);
        const ry = degToRad(rotY);
        const cosX = Math.cos(rx);
        const sinX = Math.sin(rx);
        const cosY = Math.cos(ry);
        const sinY = Math.sin(ry);

        const x1 = vec.x;
        const y1 = vec.y * cosX - vec.z * sinX;
        const z1 = vec.y * sinX + vec.z * cosX;

        const x2 = x1 * cosY + z1 * sinY;
        const y2 = y1;
        const z2 = -x1 * sinY + z1 * cosY;

        return { x: x2, y: y2, z: z2 };
      }

      function bestAxisFor(component) {
        const candidates = [
          { axis: "x", vec: { x: 1, y: 0, z: 0 }, pos: "R", neg: "L" },
          { axis: "y", vec: { x: 0, y: 1, z: 0 }, pos: "U", neg: "D" },
          { axis: "z", vec: { x: 0, y: 0, z: 1 }, pos: "F", neg: "B" },
        ];

        let best = null;
        let bestAbs = -Infinity;
        candidates.forEach((cand) => {
          const rotated = rotateVecByView(cand.vec);
          const value = rotated[component];
          const abs = Math.abs(value);
          if (abs > bestAbs) {
            bestAbs = abs;
            best = { ...cand, sign: Math.sign(value) || 1 };
          }
        });
        return best;
      }

      function getViewMapping() {
        return {
          right: bestAxisFor("x"),
          up: bestAxisFor("y"),
          front: bestAxisFor("z"),
        };
      }

      function getFrontFace() {
        const candidates = ["F", "R", "B", "L"];
        let bestFace = "F";
        let bestZ = -Infinity;
        candidates.forEach((face) => {
          const normal = normalMap[face];
          const viewNormal = rotateVecByView(normal);
          if (viewNormal.z > bestZ) {
            bestZ = viewNormal.z;
            bestFace = face;
          }
        });
        return bestFace;
      }

      function axisForFace(face) {
        if (face === "U") return { axis: "y", layer: maxCoord };
        if (face === "D") return { axis: "y", layer: minCoord };
        if (face === "R") return { axis: "x", layer: maxCoord };
        if (face === "L") return { axis: "x", layer: minCoord };
        if (face === "F") return { axis: "z", layer: maxCoord };
        return { axis: "z", layer: minCoord };
      }

      function testPointFor(frontFace, sideFace) {
        const point = { x: 0, y: maxCoord, z: 0 };
        const frontAxis = axisForFace(frontFace);
        const sideAxis = axisForFace(sideFace);
        point[frontAxis.axis] = frontAxis.layer;
        point[sideAxis.axis] = sideAxis.layer;
        return point;
      }

      function chooseTurnSign(frontFace, sideFace) {
        const { axis, layer } = axisForFace(sideFace);
        const point = testPointFor(frontFace, sideFace);
        const plus = rotate90(point, axis, 1);
        const minus = rotate90(point, axis, -1);
        const yPlus = rotateVecByView(plus).y;
        const yMinus = rotateVecByView(minus).y;
        return yPlus >= yMinus ? 1 : -1;
      }

      function parseMove(move) {
        if (typeof move === "object" && move && move.base) {
          return move;
        }
        const base = move[0];
        const modifier = move[1] || "";
        let turns = 1;
        if (modifier === "2") turns = 2;
        if (modifier === "'") turns = -1;
        return { base, turns };
      }

      function resolveViewMove(move) {
        const parsed = parseMove(move);
        if (parsed.base !== "R" && parsed.base !== "L") return parsed;

        const frontFace = getFrontFace();
        const rightMap = { F: "R", R: "B", B: "L", L: "F" };
        const leftMap = { F: "L", L: "B", B: "R", R: "F" };
        const targetFace = parsed.base === "R" ? rightMap[frontFace] : leftMap[frontFace];
        
        // chooseTurnSign returns the direction for the requested side
        const downSign = chooseTurnSign(frontFace, targetFace);
        const finalSign = downSign;

        return { base: targetFace, turns: parsed.turns * finalSign };
      }

      function updateViewIndicator() {
        if (!moveIndicatorEl) return;
        const view = getViewMapping();
        const face = view.front.sign > 0 ? view.front.pos : view.front.neg;
        const faceEl = faces[face];
        if (!faceEl) return;
        if (moveIndicatorEl.parentElement !== faceEl) {
          moveIndicatorEl.remove();
          faceEl.appendChild(moveIndicatorEl);
        }
      }

      function rotateLayer(axis, layerValue, turns) {
        const direction = turns > 0 ? 1 : -1;
        const steps = Math.abs(turns);

        for (let step = 0; step < steps; step += 1) {
          stickers = stickers.map((sticker) => {
            if (!isLayer(sticker.pos, axis, layerValue)) {
              return sticker;
            }

            const newPos = rotate90(sticker.pos, axis, direction);
            const newNormal = rotate90(sticker.normal, axis, direction);
            return {
              ...sticker,
              pos: newPos,
              normal: newNormal,
            };
          });
        }
      }

      function applyMoveState(move) {
        const resolved = resolveViewMove(move);
        const { base, turns } = resolved;

        switch (base) {
          case "U":
            rotateLayer("y", maxCoord, -turns);
            break;
          case "D":
            rotateLayer("y", minCoord, turns);
            break;
          case "R":
            rotateLayer("x", maxCoord, turns);
            break;
          case "L":
            rotateLayer("x", minCoord, -turns);
            break;
          case "F":
            rotateLayer("z", maxCoord, -turns);
            break;
          case "B":
            rotateLayer("z", minCoord, turns);
            break;
          default:
            break;
        }

        return Math.abs(turns);
      }

      function faceFromNormal(normal) {
        if (normal.y === 1) return "U";
        if (normal.y === -1) return "D";
        if (normal.z === 1) return "F";
        if (normal.z === -1) return "B";
        if (normal.x === 1) return "R";
        return "L";
      }

      function layerRotation(base, turns) {
        const { axis } = axisForFace(base);
        let sign = faceVisualSign[base] || 1;
        if (axis === "y") sign *= -1;
        return { axis, angle: turns * 90 * sign };
      }

      function buildSliceGroup(axis, layerValue) {
        const faceBuckets = {};
        const hidden = [];

        stickers.forEach((sticker) => {
          if (!isLayer(sticker.pos, axis, layerValue)) return;
          const face = faceFromNormal(sticker.normal);
          const index = getFaceIndex(face, sticker.pos);
          const row = Math.floor(index / cubeSize);
          const col = index % cubeSize;
          if (!faceBuckets[face]) faceBuckets[face] = [];
          faceBuckets[face].push({ row, col, color: sticker.color });
          const stickerEl = stickersByFace[face][index];
          if (stickerEl) {
            stickerEl.classList.add("is-hidden");
            hidden.push(stickerEl);
          }
        });

        if (!hidden.length) return null;
        const group = document.createElement("div");
        group.className = "slice-group";

        Object.entries(faceBuckets).forEach(([face, items]) => {
          const faceEl = document.createElement("div");
          faceEl.className = "face slice-face";
          faceEl.style.transform = faceTransforms[face];
          items.forEach((item) => {
            const stickerEl = document.createElement("div");
            stickerEl.className = "sticker slice-sticker";
            stickerEl.style.background = item.color;
            stickerEl.style.gridRowStart = item.row + 1;
            stickerEl.style.gridColumnStart = item.col + 1;
            faceEl.appendChild(stickerEl);
          });
          group.appendChild(faceEl);
        });

        cubeEl.appendChild(group);
        return { group, hidden };
      }

      async function animateLayer(resolved) {
        const { base, turns } = resolved;
        const { axis, layer } = axisForFace(base);
        const rotation = layerRotation(base, turns);
        const slice = buildSliceGroup(axis, layer);
        if (!slice) return [];
        const duration = Number(speedEl.value) * Math.abs(turns);
        const { group, hidden } = slice;

        group.style.transition = `transform ${duration}ms ease-in-out`;
        await new Promise((resolve) => requestAnimationFrame(resolve));
        if (rotation.axis === "x") group.style.transform = `rotateX(${rotation.angle}deg)`;
        if (rotation.axis === "y") group.style.transform = `rotateY(${rotation.angle}deg)`;
        if (rotation.axis === "z") group.style.transform = `rotateZ(${rotation.angle}deg)`;
        await sleep(duration);
        group.remove();
        return hidden;
      }

      function restoreHidden(hidden) {
        hidden.forEach((el) => el.classList.remove("is-hidden"));
      }

      function parseSequence(sequence) {
        return sequence
          .trim()
          .split(/\s+/)
          .filter(Boolean)
          .flatMap((token) => {
            const match = token.match(/^([URFDLB])([2']?)$/);
            return match ? [match[1] + match[2]] : [];
          });
      }

      function getFaceIndex(face, pos) {
        const { x, y, z } = pos;
        const idx = (value) => coords.indexOf(value);

        if (face === "U") {
          return idx(z) * cubeSize + idx(x);
        }
        if (face === "D") {
          return (cubeSize - 1 - idx(z)) * cubeSize + idx(x);
        }
        if (face === "F") {
          return (cubeSize - 1 - idx(y)) * cubeSize + idx(x);
        }
        if (face === "B") {
          return (cubeSize - 1 - idx(y)) * cubeSize + (cubeSize - 1 - idx(x));
        }
        if (face === "R") {
          return (cubeSize - 1 - idx(y)) * cubeSize + (cubeSize - 1 - idx(z));
        }
        return (cubeSize - 1 - idx(y)) * cubeSize + idx(z);
      }

      function render() {
        const faceColors = {
          U: Array(cubeSize * cubeSize).fill("#111"),
          D: Array(cubeSize * cubeSize).fill("#111"),
          F: Array(cubeSize * cubeSize).fill("#111"),
          B: Array(cubeSize * cubeSize).fill("#111"),
          L: Array(cubeSize * cubeSize).fill("#111"),
          R: Array(cubeSize * cubeSize).fill("#111"),
        };

        stickers.forEach((sticker) => {
          const n = sticker.normal;
          let face = "F";
          if (n.y === 1) face = "U";
          else if (n.y === -1) face = "D";
          else if (n.z === 1) face = "F";
          else if (n.z === -1) face = "B";
          else if (n.x === 1) face = "R";
          else if (n.x === -1) face = "L";

          const index = getFaceIndex(face, sticker.pos);
          faceColors[face][index] = sticker.color;
        });

        FACE_NAMES.forEach((face) => {
          stickersByFace[face].forEach((stickerEl, index) => {
            stickerEl.style.background = faceColors[face][index];
          });
        });
      }

      function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      async function animateFace(face, turns) {
        const faceEl = faces[face];
        if (!faceEl) return;
        const duration = Number(speedEl.value);
        const angle = 90 * turns * faceVisualSign[face];
        const base = faceTransforms[face];

        faceEl.style.transition = `transform ${duration}ms ease-in-out`;
        await new Promise((resolve) => requestAnimationFrame(resolve));
        faceEl.style.transform = `${base} rotateZ(${angle}deg)`;
        await sleep(duration);
        faceEl.style.transition = "none";
        faceEl.style.transform = base;
      }

      function enqueueMove(move) {
        moveChain = moveChain.then(async () => {
          let hidden = [];
          try {
            const resolved = resolveViewMove(move);
            const { base, turns } = resolved;

            hidden = await animateLayer(resolved);
            const delta = applyMoveState(move);
            updateMoveCount(delta);
            render();
          } catch (e) {
            console.error("Erreur lors du mouvement :", e);
          } finally {
            if (hidden.length) {
              requestAnimationFrame(() => restoreHidden(hidden));
            }
          }
        });
      }

      function enqueueMoves(moves) {
        moves.forEach((move) => enqueueMove(move));
      }

      function resetState() {
        stickers = createSolvedStickers();
        render();
        resetMoveCount();
      }

      function scramble() {
        resetMoveCount();
        const moves = ["U", "D", "L", "R", "F", "B"];
        const modifiers = ["", "'", "2"];
        const sequence = [];
        let lastMove = null;

        for (let i = 0; i < 20; i += 1) {
          let move = moves[Math.floor(Math.random() * moves.length)];
          while (move === lastMove) {
            move = moves[Math.floor(Math.random() * moves.length)];
          }
          lastMove = move;
          const mod = modifiers[Math.floor(Math.random() * modifiers.length)];
          sequence.push(move + mod);
        }

        enqueueMoves(sequence);
      }

      function applySequenceInstant(sequence) {
        parseSequence(sequence).forEach((move) => {
          applyMoveState(move);
        });
        render();
      }

      const moveList = [
        "R",
        "R'",
        "R2",
        "L",
        "L'",
        "L2",
        "U",
        "U'",
        "U2",
        "D",
        "D'",
        "D2",
        "F",
        "F'",
        "F2",
        "B",
        "B'",
        "B2",
      ];

      function moveIcon(move) {
        const isDouble = move.includes("2");
        const isPrime = move.includes("'");
        const base = move[0] || "";
        const arrow = isPrime ? "‚Ü∫" : "‚Üª";
        const label = isDouble ? "2" : "";
        const faceMap = {
          U: "--face-u",
          D: "--face-d",
          F: "--face-f",
          R: "--face-r",
          L: "--face-l",
          B: "--face-b",
        };
        const faceVar = faceMap[base] || "--face-u";
        return `
          <svg viewBox="0 0 48 48" aria-hidden="true">
            <rect x="6" y="6" width="30" height="30" rx="6" fill="var(${faceVar})" opacity="0.22" stroke="#90a0c0" stroke-width="1.2" />
            <path d="M16 6 V36 M26 6 V36 M6 16 H36 M6 26 H36" stroke="#90a0c0" stroke-width="1" opacity="0.4" />
            <text x="21" y="25" font-size="14" fill="var(${faceVar})" font-family="Space Grotesk, sans-serif" font-weight="700" text-anchor="middle">${base}</text>
            <text x="36" y="16" font-size="12" fill="#f7b32b" font-family="Space Grotesk, sans-serif">${label}</text>
            <text x="32" y="42" font-size="16" fill="#f7b32b" font-family="Space Grotesk, sans-serif">${arrow}</text>
          </svg>
        `;
      }

      function rebuildMoveButtons() {
        moveButtonsEl.innerHTML = "";
        moveList.forEach((move) => {
          const button = document.createElement("button");
          const label = document.createElement("span");
          label.textContent = move;
          const icon = document.createElement("span");
          icon.className = "move-icon";
          icon.innerHTML = moveIcon(move);
          button.appendChild(label);
          button.appendChild(icon);
          button.addEventListener("click", () => enqueueMove(move));
          moveButtonsEl.appendChild(button);
        });
      }

      const algoSequences = {
        sexy: ["R", "U", "R'", "U'"],
        "left-hat": ["U'", "L'", "U", "L", "U", "F", "U'", "F'"],
        "right-hat": ["U", "R", "U'", "R'", "U'", "F'", "U", "F"],
        "yellow-cross": ["F", "R", "U", "R'", "U'", "F'"],
        chair: ["R", "U2", "R'", "U'", "R", "U'", "R'"],
        "left-chair": ["L'", "U2", "L", "U", "L'", "U", "L"],
        "right-friends": ["R", "U'", "L'", "U", "R'", "U'", "L", "U"],
        "left-friends": ["L'", "U", "R", "U'", "L", "U", "R'", "U'"],
      };
      const algoSteps = Object.keys(algoSequences).reduce((acc, key) => {
        acc[key] = 0;
        return acc;
      }, {});
      const algoSpans = {};
      let notationMode = "standard";

      document.querySelectorAll(".algo-main").forEach((button) => {
        const label = button.dataset.label || "";
        const sequence = (button.dataset.seq || "").trim().split(/\s+/).filter(Boolean);
        const seqSpans = sequence
          .map((move) => {
            const face = move[0] || "";
            return `<span class="move-step" data-move="${move}" data-face="${face}">${move}</span>`;
          })
          .join(" ");
        button.innerHTML = `<span class="algo-label">${label} ¬∑ ${seqSpans}</span>`;
        if (button.dataset.algo) {
          algoSpans[button.dataset.algo] = Array.from(button.querySelectorAll(".move-step"));
        }
      });
      applyNotation(notationMode);

      function formatMoveDisplay(move, mode) {
        const base = move[0] || "";
        const modifier = move[1] || "";
        if (modifier === "2") return `${base}2`;
        if (mode === "lowercase") {
          return modifier === "'" ? base.toLowerCase() : base;
        }
        if (mode === "arrows") {
          if (base === "U") {
            return modifier === "'" ? `${base}‚Üê` : `${base}‚Üí`;
          }
          return modifier === "'" ? `${base}‚Üì` : `${base}‚Üë`;
        }
        return modifier === "'" ? `${base}'` : base;
      }

      function applyNotation(mode) {
        notationMode = mode;
        document.documentElement.classList.toggle("notation-lowercase", mode === "lowercase");
        Object.values(algoSpans).forEach((spans) => {
          spans.forEach((span) => {
            span.textContent = formatMoveDisplay(span.dataset.move || "", mode);
          });
        });
      }

      function highlightAlgoStep(key, index) {
        const spans = algoSpans[key];
        if (!spans || !spans.length) return;
        spans.forEach((span, idx) => {
          span.classList.toggle("active", idx === index);
        });
      }

      function clearAlgoHighlight(key) {
        const spans = algoSpans[key];
        if (!spans) return;
        spans.forEach((span) => span.classList.remove("active"));
      }

      function stepAlgo(key) {
        const sequence = algoSequences[key];
        if (!sequence) return;
        const index = algoSteps[key] % sequence.length;
        highlightAlgoStep(key, index);
        algoSteps[key] = (index + 1) % sequence.length;
        enqueueMove(sequence[index]);
      }

      function resetAlgo(key) {
        if (!(key in algoSteps)) return;
        algoSteps[key] = 0;
        clearAlgoHighlight(key);
      }

      function resetAllAlgos() {
        Object.keys(algoSteps).forEach((key) => resetAlgo(key));
      }

      document.querySelectorAll(".algo-step").forEach((button) => {
        button.addEventListener("click", () => {
          stepAlgo(button.dataset.algo);
        });
      });

      const notationEl = document.getElementById("algo-notation");
      if (notationEl) {
        notationEl.querySelectorAll("button").forEach((button) => {
          button.addEventListener("click", () => {
            notationEl.querySelectorAll("button").forEach((b) => b.classList.remove("active"));
            button.classList.add("active");
            applyNotation(button.dataset.notation || "standard");
          });
        });
      }

      document.getElementById("apply-sequence").addEventListener("click", () => {
        const input = document.getElementById("sequence-input");
        const moves = parseSequence(input.value);
        enqueueMoves(moves);
      });

      document.getElementById("reset").addEventListener("click", () => {
        resetState();
        resetAllAlgos();
      });

      document.getElementById("scramble").addEventListener("click", () => {
        scramble();
      });

      document.getElementById("sexy-move").addEventListener("click", () => {
        resetAlgo("sexy");
        enqueueMoves(algoSequences.sexy);
      });
      document.getElementById("left-hat").addEventListener("click", () => {
        resetAlgo("left-hat");
        enqueueMoves(algoSequences["left-hat"]);
      });

      document.getElementById("right-hat").addEventListener("click", () => {
        resetAlgo("right-hat");
        enqueueMoves(algoSequences["right-hat"]);
      });

      document.getElementById("yellow-cross").addEventListener("click", () => {
        resetAlgo("yellow-cross");
        enqueueMoves(algoSequences["yellow-cross"]);
      });

      document.getElementById("chair").addEventListener("click", () => {
        resetAlgo("chair");
        enqueueMoves(algoSequences.chair);
      });

      document.getElementById("left-chair").addEventListener("click", () => {
        resetAlgo("left-chair");
        enqueueMoves(algoSequences["left-chair"]);
      });

      document.getElementById("right-friends").addEventListener("click", () => {
        resetAlgo("right-friends");
        enqueueMoves(algoSequences["right-friends"]);
      });

      document.getElementById("left-friends").addEventListener("click", () => {
        resetAlgo("left-friends");
        enqueueMoves(algoSequences["left-friends"]);
      });

      cubeTypeEl.addEventListener("change", () => {
        const value = cubeTypeEl.value;
        let size = 3;
        let preset = null;
        if (value === "2") size = 2;
        if (value === "3") size = 3;
        if (value === "4") size = 4;
        if (value === "3-twisted") {
          size = 3;
          preset = TWISTED_SEQUENCE;
        }

        buildCube(size);
        stickers = createSolvedStickers();
        render();
        resetMoveCount();
        if (preset) {
          applySequenceInstant(preset);
        }
      });

      rebuildMoveButtons();
      buildCube(cubeSize);
      resetState();

      if (speedSegmentEl) {
        speedSegmentEl.querySelectorAll("button").forEach((button) => {
          button.addEventListener("click", () => {
            speedSegmentEl.querySelectorAll("button").forEach((b) => b.classList.remove("active"));
            button.classList.add("active");
            speedEl.value = button.dataset.speed;
          });
        });
      }

      const viewport = document.getElementById("viewport");
      let isDragging = false;
      let lastX = 0;
      let lastY = 0;
       let rotX = -15;
       let rotY = -15;

       function updateCubeRotation() {
         cubeEl.style.transform = `rotateX(${rotX}deg) rotateY(${rotY}deg)`;
         const coordsOverlay = document.getElementById("coords-overlay");
         if (coordsOverlay) {
           coordsOverlay.textContent = `rotX: ${Math.round(rotX)}, rotY: ${Math.round(rotY)}`;
         }
         updateViewIndicator();
       }

      viewport.addEventListener("pointerdown", (event) => {
        isDragging = true;
        lastX = event.clientX;
        lastY = event.clientY;
        viewport.setPointerCapture(event.pointerId);
      });

      viewport.addEventListener("pointermove", (event) => {
        if (!isDragging) return;
        const dx = event.clientX - lastX;
        const dy = event.clientY - lastY;
        rotY += dx * 0.5;
        rotX -= dy * 0.5;
        rotX = Math.max(-80, Math.min(80, rotX));
        lastX = event.clientX;
        lastY = event.clientY;
        updateCubeRotation();
      });

      viewport.addEventListener("pointerup", () => {
        isDragging = false;
      });

      viewport.addEventListener("pointerleave", () => {
        isDragging = false;
      });

      updateCubeRotation();
    </script>
  </body>
</html>
